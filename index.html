<!DOCTYPE html>
<html>
<head>
    <title>Generals</title>
    <style>
        body { 
            font-family: monospace; 
            background: #1a1a1a; 
            color: #e0e0e0; 
            padding: 20px; 
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            width: 100%;
        }
        .header { 
            margin-bottom: 20px; 
        }
        .grid { 
            font-size: 14px; 
            line-height: 1.2; 
            white-space: pre; 
            font-family: 'Courier New', Courier, monospace;
            margin: 20px 0;
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
        }
        .status { 
            margin: 20px 0; 
        }
        .winner { 
            font-size: 24px; 
            font-weight: bold;
            color: #ffdd44;
        }
        .units { 
            display: flex; 
            gap: 40px; 
            margin: 20px 0; 
        }
        .legend { 
            margin: 20px 0;
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
        }
        .command-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #555;
            background: #2a2a2a;
            border-radius: 8px;
        }
        .command-section h3 {
            margin-top: 0;
            color: #e0e0e0;
        }
        .command-section input {
            background: #333;
            color: #e0e0e0;
            border: 1px solid #555;
            border-radius: 4px;
        }
        .command-section button {
            background: #4a4a4a;
            color: #e0e0e0;
            border: 1px solid #666;
            border-radius: 4px;
        }
        .command-section button:hover {
            background: #5a5a5a;
        }
        .api-info {
            margin-top: 40px;
            padding: 20px;
            border: 1px solid #555;
            background: #2a2a2a;
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
    <div class="header">
        <h1>Generals</h1>
        <p>Turn: <span id="turnNumber">0</span></p>
    </div>
    
    <div id="winnerDisplay"></div>
    
    <div class="grid" id="gameGrid">Loading...</div>

    
    <div class="command-section">
        <form id="commandForm">
            <input type="text" id="commandInput" placeholder="Enter command for blue units (e.g., 'Defend the blue cities')" style="width: 400px; padding: 8px; margin-right: 10px;">
            <button type="submit" style="padding: 8px 15px;">Execute</button>
        </form>
        <div id="commandStatus" style="margin-top: 10px; font-style: italic; color: #aaa;"></div>
    </div>


    <div class="status" id="cityStatus">
        <strong>Cities Remaining:</strong><br>
        Blue: - | Red: -
    </div>


    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    <br>
    
    <div class="legend">
        <strong>Legend:</strong><br>
        B0-B4 = Blue units | r0-r4 = Red units<br>
        C = Blue cities | c = Red cities | ^ = Mountains | . = Empty
    </div>
    
    <div class="units" id="unitsDisplay">
        <div>
            <h3>Blue Forces</h3>
            <div id="blueUnits">Loading...</div>
        </div>
        <div>
            <h3>Red Forces</h3>
            <div id="redUnits">Loading...</div>
        </div>
    </div>
    

    <script>
        function generateAsciiGrid(gameState) {
            const GRID_SIZE = 20;
            let grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));

            // Initialize with dots
            for(let r=0; r<GRID_SIZE; r++) {
                for(let c=0; c<GRID_SIZE; c++) {
                    grid[r][c] = `<span style="color: #444">.  </span>`;
                }
            }

            // Place mountains
            if (gameState.mountains) {
                for (let mountain of gameState.mountains) {
                    grid[mountain.y][mountain.x] = `<span style="color: #bbb; font-weight: bold;">^  </span>`;
                }
            }
            
            // Place cities
            for (let city of gameState.cities) {
                const color = city.side === 'blue' ? '#4da6ff' : 'red';
                const symbol = city.side === 'blue' ? 'C' : 'c';
                grid[city.y][city.x] = `<span style="color: ${color}">${symbol.padEnd(3, ' ')}</span>`;
            }
            
            // Place units (units override cities on display)
            for (let unit of gameState.units.filter(u => u.hp > 0)) {
                let symbol = unit.side === 'blue' ? unit.id : unit.id.toLowerCase();
                const color = unit.side === 'blue' ? '#4da6ff' : 'red';
                
                // Check if this unit took damage this turn
                const damageEvent = gameState.events && gameState.events.find(e => 
                    e.type === 'damage' && e.x === unit.x && e.y === unit.y
                );
                const background = damageEvent ? 'background-color: lightcoral; ' : '';
                
                grid[unit.y][unit.x] = `<span style="color: ${color}; ${background}">${symbol.padEnd(3, ' ')}</span>`;
            }
            
            // Add event overlays (stars for kills and captures)
            if (gameState.events) {
                for (let event of gameState.events) {
                    if (event.type === 'kill' || event.type === 'capture') {
                        // Show bright red star overlay
                        const currentCell = grid[event.y][event.x];
                        if (currentCell.includes('</span>')) {
                            // Replace the content but keep the span structure
                            grid[event.y][event.x] = currentCell.replace(/>[^<]*<\/span>/, `>★  </span>`).replace(/color: [^;]*;/, 'color: red; font-weight: bold;');
                        } else {
                            grid[event.y][event.x] = `<span style="color: red; font-weight: bold;">★  </span>`;
                        }
                    }
                }
            }
            
            // Pad each cell to 3 characters for consistent spacing
            return grid.map(row => row.join('')).join('\n');
        }

        async function fetchGameState() {
            try {
                const response = await fetch('/state');
                if (!response.ok) throw new Error('Network response was not ok');
                const gameState = await response.json();
                
                updateDisplay(gameState);
            } catch (error) {
                console.error('Error fetching game state:', error);
            }
        }

        function updateDisplay(gameState) {
            // Update turn number
            document.getElementById('turnNumber').textContent = gameState.turn;
            
            // Update winner display
            const winnerDisplay = document.getElementById('winnerDisplay');
            if (gameState.winner) {
                winnerDisplay.innerHTML = `<div class="winner">${gameState.winner.toUpperCase()} WINS!</div>`;
            } else {
                winnerDisplay.innerHTML = '';
            }
            
            // Update grid
            document.getElementById('gameGrid').innerHTML = generateAsciiGrid(gameState);
            
            // Update units
            const aliveUnits = gameState.units.filter(u => u.hp > 0);
            const blueUnits = aliveUnits.filter(u => u.side === 'blue');
            const redUnits = aliveUnits.filter(u => u.side === 'red');
            
            document.getElementById('blueUnits').innerHTML = blueUnits
                .map(u => {
                    let orderText = '';
                    if (u.orderQueue && u.orderQueue.length > 0) {
                        const currentOrder = u.orderQueue[0];
                        if (currentOrder.action === 'move') {
                            orderText = ` - moving ${currentOrder.direction} (${currentOrder.tiles} tiles)`;
                        } else if (currentOrder.action === 'move_to') {
                            orderText = ` - moving to (${currentOrder.target.x},${currentOrder.target.y})`;
                        }
                        if (u.orderQueue.length > 1) {
                            orderText += ` [+${u.orderQueue.length - 1} queued]`;
                        }
                    }
                    return `<span style="color: #4da6ff">${u.id}: HP ${u.hp} at (${u.x},${u.y})${orderText}</span>`;
                })
                .join('<br>') || 'No units remaining';
                
            document.getElementById('redUnits').innerHTML = redUnits
                .map(u => {
                    let orderText = '';
                    if (u.orderQueue && u.orderQueue.length > 0) {
                        const currentOrder = u.orderQueue[0];
                        if (currentOrder.action === 'move') {
                            orderText = ` - moving ${currentOrder.direction} (${currentOrder.tiles} tiles)`;
                        } else if (currentOrder.action === 'move_to') {
                            orderText = ` - moving to (${currentOrder.target.x},${currentOrder.target.y})`;
                        }
                        if (u.orderQueue.length > 1) {
                            orderText += ` [+${u.orderQueue.length - 1} queued]`;
                        }
                    }
                    return `<span style="color: red">${u.id}: HP ${u.hp} at (${u.x},${u.y})${orderText}</span>`;
                })
                .join('<br>') || 'No units remaining';
            
            // Update city status
            const blueCities = gameState.cities.filter(c => c.side === 'blue').length;
            const redCities = gameState.cities.filter(c => c.side === 'red').length;
            document.getElementById('cityStatus').innerHTML = 
                `<strong>Cities Remaining:</strong><br>Blue: ${blueCities} | Red: ${redCities}`;
            
            // Run enemy AI
            executeEnemyAI(gameState);
        }

        // Enemy AI System
        let aiEnabled = true;
        let lastAiMoveTime = 0;
        const AI_MOVE_INTERVAL = 10000; // 10 seconds between moves

        function executeEnemyAI(gameState) {
            if (!aiEnabled || gameState.winner) return;
            
            const now = Date.now();
            if (now - lastAiMoveTime < AI_MOVE_INTERVAL) return;
            
            // Get alive red units
            const redUnits = gameState.units.filter(u => u.side === 'red' && u.hp > 0);
            if (redUnits.length === 0) return;
            
            // Pick a random red unit
            const unit = redUnits[Math.floor(Math.random() * redUnits.length)];
            
            let targetX, targetY;
            
            // 10% chance to target a city, 90% chance for random/blue unit
            if (Math.random() < 0.1) {
                // Target a blue city if available
                const blueCities = gameState.cities.filter(c => c.side === 'blue');
                if (blueCities.length > 0) {
                    const targetCity = blueCities[Math.floor(Math.random() * blueCities.length)];
                    targetX = targetCity.x;
                    targetY = targetCity.y;
                } else {
                    // No blue cities, pick random spot
                    targetX = Math.floor(Math.random() * 20);
                    targetY = Math.floor(Math.random() * 20);
                }
            } else {
                // 50% chance to target a blue unit, 50% chance random spot
                const blueUnits = gameState.units.filter(u => u.side === 'blue' && u.hp > 0);
                if (blueUnits.length > 0 && Math.random() < 0.5) {
                    // Target a blue unit
                    const targetUnit = blueUnits[Math.floor(Math.random() * blueUnits.length)];
                    targetX = targetUnit.x;
                    targetY = targetUnit.y;
                } else {
                    // Random spot
                    targetX = Math.floor(Math.random() * 20);
                    targetY = Math.floor(Math.random() * 20);
                }
            }
            
            // Issue the move command
            const moveOrder = {
                unit: unit.id,
                action: 'move_to',
                target: { x: targetX, y: targetY }
            };
            
            fetch('/order', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(moveOrder)
            }).catch(error => {
                console.error('AI move error:', error);
            });
            
            lastAiMoveTime = now;
        }

        // Command form handling
        document.getElementById('commandForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const commandInput = document.getElementById('commandInput');
            const statusDiv = document.getElementById('commandStatus');
            const command = commandInput.value.trim();
            
            if (!command) return;
            
            statusDiv.textContent = 'Processing command...';
            statusDiv.style.color = '#666';
            
            try {
                // Get current game state
                const stateResponse = await fetch('/state');
                const gameState = await stateResponse.json();
                
                // Prepare chat request with game state
                const chatRequest = {
                    gameState: gameState,  // Pass game state to server for prompt generation
                    messages: [
                        {
                            role: "user",
                            content: command
                        }
                    ]
                };
                
                // Send chat request
                const chatResponse = await fetch('/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(chatRequest)
                });
                
                if (!chatResponse.ok) {
                    throw new Error(`Chat API error: ${chatResponse.status}`);
                }
                
                const chatResult = await chatResponse.json();
                
                // Process tool calls
                if (chatResult.choices && chatResult.choices[0] && chatResult.choices[0].message && chatResult.choices[0].message.tool_calls) {
                    const toolCalls = chatResult.choices[0].message.tool_calls;
                    let executedMoves = 0;
                    
                    for (const toolCall of toolCalls) {
                        if (toolCall.type === 'function' && toolCall.function.name === 'issue_orders') {
                            const args = JSON.parse(toolCall.function.arguments);
                            
                            // Process each order in the orders array
                            for (const order of args.orders) {
                                let moveOrder;
                                
                                if (order.action === 'move') {
                                    moveOrder = {
                                        unit: order.unit,
                                        action: 'move',
                                        direction: order.direction,
                                        tiles: order.tiles
                                    };
                                } else if (order.action === 'move_to') {
                                    moveOrder = {
                                        unit: order.unit,
                                        action: 'move_to',
                                        target: order.target
                                    };
                                }
                                
                                if (moveOrder) {
                                    const orderResponse = await fetch('/order', {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json'
                                        },
                                        body: JSON.stringify(moveOrder)
                                    });
                                    
                                    if (orderResponse.ok) {
                                        executedMoves++;
                                    }
                                }
                            }
                        }
                    }
                    
                    if (executedMoves > 0) {
                        statusDiv.textContent = `Executed ${executedMoves} move(s) successfully`;
                        statusDiv.style.color = 'green';
                        commandInput.value = '';
                    } else {
                        statusDiv.textContent = 'No valid moves found in response.';
                        statusDiv.style.color = 'orange';
                    }
                } else {
                    statusDiv.textContent = 'AI response did not include any moves.';
                    statusDiv.style.color = 'orange';
                }
                
            } catch (error) {
                console.error('Command execution error:', error);
                statusDiv.textContent = `Error: ${error.message}`;
                statusDiv.style.color = 'red';
            }
        });

        // Initialize
        fetchGameState(); // Initial load
        setInterval(fetchGameState, 500); // Auto-refresh every 500ms
    </script>
    </div>
</body>
</html>
