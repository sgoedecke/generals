<!DOCTYPE html>
<html>
<head>
    <title>Wargame Battle Grid</title>
    <style>
        body { 
            font-family: monospace; 
            background: white; 
            color: black; 
            padding: 20px; 
            margin: 0;
        }
        .header { 
            margin-bottom: 20px; 
        }
        .grid { 
            font-size: 14px; 
            line-height: 1.2; 
            white-space: pre; 
            font-family: 'Courier New', Courier, monospace;
            margin: 20px 0;
        }
        .status { 
            margin: 20px 0; 
        }
        .winner { 
            font-size: 24px; 
            font-weight: bold; 
        }
        .units { 
            display: flex; 
            gap: 40px; 
            margin: 20px 0; 
        }
        .legend { 
            margin: 20px 0; 
        }
        .command-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ccc;
            background: #f9f9f9;
        }
        .command-section h3 {
            margin-top: 0;
        }
        .api-info {
            margin-top: 40px;
            padding: 20px;
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Wargame Battle Grid</h1>
        <p>Turn: <span id="turnNumber">0</span></p>
    </div>
    
    <div id="winnerDisplay"></div>
    
    <div class="grid" id="gameGrid">Loading...</div>
    
    <div class="legend">
        <strong>Legend:</strong><br>
        B0-B4 = Blue units | r0-r4 = Red units<br>
        C = Blue cities | c = Red cities | ^ = Mountains | . = Empty
    </div>
    
    <div class="command-section">
        <form id="commandForm">
            <input type="text" id="commandInput" placeholder="Enter command for blue units (e.g., 'Move B0 south 3 tiles')" style="width: 400px; padding: 8px; margin-right: 10px;">
            <button type="submit" style="padding: 8px 15px;">Execute</button>
        </form>
        <div id="commandStatus" style="margin-top: 10px; font-style: italic; color: #666;"></div>
    </div>
    
    <div class="units" id="unitsDisplay">
        <div>
            <h3>Blue Forces</h3>
            <div id="blueUnits">Loading...</div>
        </div>
        <div>
            <h3>Red Forces</h3>
            <div id="redUnits">Loading...</div>
        </div>
    </div>
    
    <div class="status" id="cityStatus">
        <strong>Cities Remaining:</strong><br>
        Blue: - | Red: -
    </div>

    <script>
        function generateAsciiGrid(gameState) {
            const GRID_SIZE = 20;
            let grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));

            // Initialize with dots
            for(let r=0; r<GRID_SIZE; r++) {
                for(let c=0; c<GRID_SIZE; c++) {
                    grid[r][c] = `<span style="color: lightgrey">.  </span>`;
                }
            }

            // Place mountains
            if (gameState.mountains) {
                for (let mountain of gameState.mountains) {
                    grid[mountain.y][mountain.x] = `<span style="color: black">^  </span>`;
                }
            }
            
            // Place cities
            for (let city of gameState.cities) {
                const color = city.side === 'blue' ? 'blue' : 'red';
                const symbol = city.side === 'blue' ? 'C' : 'c';
                grid[city.y][city.x] = `<span style="color: ${color}">${symbol.padEnd(3, ' ')}</span>`;
            }
            
            // Place units (units override cities on display)
            for (let unit of gameState.units.filter(u => u.hp > 0)) {
                let symbol = unit.side === 'blue' ? unit.id : unit.id.toLowerCase();
                const color = unit.side === 'blue' ? 'blue' : 'red';
                grid[unit.y][unit.x] = `<span style="color: ${color}">${symbol.padEnd(3, ' ')}</span>`;
            }
            
            // Pad each cell to 3 characters for consistent spacing
            return grid.map(row => row.join('')).join('\n');
        }

        async function fetchGameState() {
            try {
                const response = await fetch('/state');
                if (!response.ok) throw new Error('Network response was not ok');
                const gameState = await response.json();
                
                updateDisplay(gameState);
            } catch (error) {
                console.error('Error fetching game state:', error);
            }
        }

        function updateDisplay(gameState) {
            // Update turn number
            document.getElementById('turnNumber').textContent = gameState.turn;
            
            // Update winner display
            const winnerDisplay = document.getElementById('winnerDisplay');
            if (gameState.winner) {
                winnerDisplay.innerHTML = `<div class="winner">${gameState.winner.toUpperCase()} WINS!</div>`;
            } else {
                winnerDisplay.innerHTML = '';
            }
            
            // Update grid
            document.getElementById('gameGrid').innerHTML = generateAsciiGrid(gameState);
            
            // Update units
            const aliveUnits = gameState.units.filter(u => u.hp > 0);
            const blueUnits = aliveUnits.filter(u => u.side === 'blue');
            const redUnits = aliveUnits.filter(u => u.side === 'red');
            
            document.getElementById('blueUnits').innerHTML = blueUnits
                .map(u => {
                    let orderText = '';
                    if (u.orderQueue && u.orderQueue.length > 0) {
                        const currentOrder = u.orderQueue[0];
                        if (currentOrder.action === 'move') {
                            orderText = ` - moving ${currentOrder.direction} (${currentOrder.tiles} tiles)`;
                        } else if (currentOrder.action === 'move_to') {
                            orderText = ` - moving to (${currentOrder.target.x},${currentOrder.target.y})`;
                        }
                        if (u.orderQueue.length > 1) {
                            orderText += ` [+${u.orderQueue.length - 1} queued]`;
                        }
                    }
                    return `<span style="color: blue">${u.id}: HP ${u.hp} at (${u.x},${u.y})${orderText}</span>`;
                })
                .join('<br>') || 'No units remaining';
                
            document.getElementById('redUnits').innerHTML = redUnits
                .map(u => {
                    let orderText = '';
                    if (u.orderQueue && u.orderQueue.length > 0) {
                        const currentOrder = u.orderQueue[0];
                        if (currentOrder.action === 'move') {
                            orderText = ` - moving ${currentOrder.direction} (${currentOrder.tiles} tiles)`;
                        } else if (currentOrder.action === 'move_to') {
                            orderText = ` - moving to (${currentOrder.target.x},${currentOrder.target.y})`;
                        }
                        if (u.orderQueue.length > 1) {
                            orderText += ` [+${u.orderQueue.length - 1} queued]`;
                        }
                    }
                    return `<span style="color: red">${u.id}: HP ${u.hp} at (${u.x},${u.y})${orderText}</span>`;
                })
                .join('<br>') || 'No units remaining';
            
            // Update city status
            const blueCities = gameState.cities.filter(c => c.side === 'blue').length;
            const redCities = gameState.cities.filter(c => c.side === 'red').length;
            document.getElementById('cityStatus').innerHTML = 
                `<strong>Cities Remaining:</strong><br>Blue: ${blueCities} | Red: ${redCities}`;
        }

        // Command form handling
        document.getElementById('commandForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const commandInput = document.getElementById('commandInput');
            const statusDiv = document.getElementById('commandStatus');
            const command = commandInput.value.trim();
            
            if (!command) return;
            
            statusDiv.textContent = 'Processing command...';
            statusDiv.style.color = '#666';
            
            try {
                // Get current game state
                const stateResponse = await fetch('/state');
                const gameState = await stateResponse.json();
                
                // Prepare chat request with game context
                const chatRequest = {
                    messages: [
                        {
                            role: "system",
                            content: `You are controlling the blue team in a wargame. Current game state: Turn ${gameState.turn}. 
                            Blue units: ${gameState.units.filter(u => u.side === 'blue' && u.hp > 0).map(u => `${u.id} at (${u.x},${u.y}) HP:${u.hp}`).join(', ')}.
                            Red units: ${gameState.units.filter(u => u.side === 'red' && u.hp > 0).map(u => `${u.id} at (${u.x},${u.y}) HP:${u.hp}`).join(', ')}.
                            Blue cities: ${gameState.cities.filter(c => c.side === 'blue').map(c => `(${c.x},${c.y})`).join(', ')}.
                            Red cities: ${gameState.cities.filter(c => c.side === 'red').map(c => `(${c.x},${c.y})`).join(', ')}.
                            Mountains: ${gameState.mountains.map(m => `(${m.x},${m.y})`).join(', ')}.
                            Grid size: 20x20 (0-19 coordinates). Use the available tools to execute the user's command.
                            You can issue multiple move orders in a single command, including to the same unit multiple times (e.g. to move in a particular pattern).
                            If your unit moves into a city, it will attack and capture that city. If your unit moves into another unit's position, it will attack that unit and they will both lose HP. Units cannot move through mountains.
                            'In front of a city' in this context means in between the city and the red team's units.`,
                        },
                        {
                            role: "user",
                            content: command
                        }
                    ]
                };
                
                // Send chat request
                const chatResponse = await fetch('/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(chatRequest)
                });
                
                if (!chatResponse.ok) {
                    throw new Error(`Chat API error: ${chatResponse.status}`);
                }
                
                const chatResult = await chatResponse.json();
                
                // Process tool calls
                if (chatResult.choices && chatResult.choices[0] && chatResult.choices[0].message && chatResult.choices[0].message.tool_calls) {
                    const toolCalls = chatResult.choices[0].message.tool_calls;
                    let executedMoves = 0;
                    
                    for (const toolCall of toolCalls) {
                        if (toolCall.type === 'function') {
                            const functionName = toolCall.function.name;
                            const args = JSON.parse(toolCall.function.arguments);
                            
                            if (functionName === 'move_unit_direction') {
                                const moveOrder = {
                                    unit: args.unit,
                                    action: 'move',
                                    direction: args.direction,
                                    tiles: args.tiles
                                };
                                
                                const orderResponse = await fetch('/order', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify(moveOrder)
                                });
                                
                                if (orderResponse.ok) {
                                    executedMoves++;
                                }
                            } else if (functionName === 'move_unit_to_position') {
                                const moveOrder = {
                                    unit: args.unit,
                                    action: 'move_to',
                                    target: { x: args.x, y: args.y }
                                };
                                
                                const orderResponse = await fetch('/order', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify(moveOrder)
                                });
                                
                                if (orderResponse.ok) {
                                    executedMoves++;
                                }
                            }
                        }
                    }
                    
                    if (executedMoves > 0) {
                        statusDiv.textContent = `Executed ${executedMoves} move(s) successfully`;
                        statusDiv.style.color = 'green';
                        commandInput.value = '';
                    } else {
                        statusDiv.textContent = 'No valid moves found in response.';
                        statusDiv.style.color = 'orange';
                    }
                } else {
                    statusDiv.textContent = 'AI response did not include any moves.';
                    statusDiv.style.color = 'orange';
                }
                
            } catch (error) {
                console.error('Command execution error:', error);
                statusDiv.textContent = `Error: ${error.message}`;
                statusDiv.style.color = 'red';
            }
        });

        // Initialize
        fetchGameState(); // Initial load
        setInterval(fetchGameState, 500); // Auto-refresh every 500ms
    </script>
</body>
</html>
